generator client {
  provider      = "prisma-client-js"
  output        = "../src/generated/prisma"
  binaryTargets = ["native", "windows"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Authentication ───

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// ─── Users & Profiles ───

enum UserRole {
  PATIENT
  CONTRIBUTOR
  BOTH
  ADMIN
}

enum ActivityLevel {
  SEDENTARY
  LIGHTLY_ACTIVE
  MODERATELY_ACTIVE
  ACTIVE
  ATHLETE
}

model User {
  id             String    @id @default(cuid())
  name           String?
  email          String?   @unique
  emailVerified  DateTime?
  image          String?
  passwordHash   String?
  role           UserRole  @default(PATIENT)
  bio            String?   @db.Text
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Stripe Connect (for contributor payouts)
  stripeConnectId        String?
  stripeConnectOnboarded Boolean @default(false)

  // Stripe Customer (for subscription billing)
  stripeCustomerId              String?
  subscriptionStatus            String?    // "active", "trialing", "canceled", "past_due"
  subscriptionPlan              String?    // "monthly", "annual"
  subscriptionCurrentPeriodEnd  DateTime?
  subscriptionCancelAtPeriodEnd Boolean    @default(false)
  stripeSubscriptionId          String?    @unique

  accounts       Account[]
  sessions       Session[]
  profile        Profile?
  recordings     Recording[]
  callsAsPatient Call[]     @relation("PatientCalls")
  callsAsContributor Call[] @relation("ContributorCalls")
  reviewsGiven   Review[]   @relation("ReviewAuthor")
  reviewsReceived Review[]  @relation("ReviewSubject")
  availability   Availability[]
  payments       Payment[]
  recordingAccess RecordingAccess[]
  reportsSubmitted Report[] @relation("ReportsSubmitted")
  reportsReceived  Report[] @relation("ReportsReceived")
  series         RecordingSeries[] @relation("UserSeries")
  seriesAccess   SeriesAccess[]
  subscriberViews SubscriberView[]
  groupSessionsHosted  GroupSession[]             @relation("ContributorGroupSessions")
  groupSessionsJoined  GroupSessionParticipant[]
  recommendationsCreated Recommendation[]         @relation("RecommendationsCreated")
  endorsements         RecommendationEndorsement[] @relation("UserEndorsements")
  recommendationVotes  RecommendationVote[]       @relation("UserRecommendationVotes")
  recommendationComments RecommendationComment[]  @relation("UserRecommendationComments")
  conversationsAsP1      Conversation[]             @relation("ConversationParticipant1")
  conversationsAsP2      Conversation[]             @relation("ConversationParticipant2")
  messagesSent           Message[]                  @relation("MessageSender")
  journalEntries         JournalEntry[]
  journalSharesGiven     JournalShare[]  @relation("PatientJournalShares")
  journalSharesReceived  JournalShare[]  @relation("ContributorJournalShares")
}

model Profile {
  id                String        @id @default(cuid())
  userId            String        @unique
  user              User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Matching attributes
  procedureType     String        // Primary procedure (for backwards compatibility)
  procedureTypes    String[]      // All procedures (contributors can have multiple)
  activeProcedureType String?     // Currently active procedure for display
  procedureProfiles Json?         // Per-procedure data: { [procedureType]: { details, goals, etc } }
  conditionCategory String?       @default("SURGERY") // "SURGERY" or "CHRONIC_PAIN"
  procedureDetails  String?       // e.g., "Patellar tendon graft"
  ageRange          String        // e.g., "20s", "30s", "40s"
  activityLevel     ActivityLevel
  recoveryGoals     String[]      // e.g., ["Return to competitive sport"]
  timeSinceSurgery  String?       // e.g., "3 months", "1 year" (contributors only)
  surgeryDate       DateTime?
  complicatingFactors String[]    // e.g., ["Revision surgery", "Bilateral"]
  lifestyleContext  String[]      // e.g., ["Parent of young kids", "Works from home"]

  // Contributor-specific
  hourlyRate        Float?        // For live calls (in dollars)
  isAvailableForCalls Boolean     @default(false)

  // Intro video
  introVideoUrl     String?       // S3 URL for uploaded intro video
  introVideoDuration Int?         // Duration in seconds

  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
}

// ─── Tier 1: Recorded Content ───

enum RecordingStatus {
  DRAFT
  PENDING_REVIEW
  PUBLISHED
  REJECTED
}

enum RecordingCategory {
  WEEKLY_TIMELINE
  WISH_I_KNEW
  PRACTICAL_TIPS
  MENTAL_HEALTH
  RETURN_TO_ACTIVITY
  MISTAKES_AND_LESSONS
}

enum TranscriptionStatus {
  NONE
  PENDING
  COMPLETED
  FAILED
}

model FaqPrompt {
  id            String            @id @default(cuid())
  question      String
  category      RecordingCategory
  conditionType String?           @default("SURGERY")
  isActive      Boolean           @default(true)
  sortOrder     Int               @default(0)
  createdAt     DateTime          @default(now())
  recordings    Recording[]
}

model Recording {
  id              String            @id @default(cuid())
  contributorId   String
  contributor     User              @relation(fields: [contributorId], references: [id])

  title           String
  description     String?           @db.Text
  category        RecordingCategory
  mediaUrl        String            // S3/cloud storage URL
  thumbnailUrl    String?
  durationSeconds Int?
  isVideo         Boolean           @default(false)

  // FAQ prompt association
  faqPromptId     String?
  faqPrompt       FaqPrompt?        @relation(fields: [faqPromptId], references: [id])

  // Transcription
  transcription       String?           @db.Text
  transcriptionStatus TranscriptionStatus @default(NONE)

  // Denormalized from contributor profile for search
  procedureType   String
  ageRange        String
  activityLevel   ActivityLevel
  recoveryGoals   String[]

  status          RecordingStatus   @default(DRAFT)
  viewCount       Int               @default(0)
  price           Float             @default(4.99) // Per-recording price

  reviews         Review[]
  purchases       RecordingAccess[]
  reports         Report[]
  seriesMemberships SeriesRecording[]
  subscriberViews SubscriberView[]
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([procedureType])
  @@index([status])
  @@index([faqPromptId])
}

// ─── Tier 2: Live Calls ───

enum CallStatus {
  REQUESTED
  CONFIRMED
  COMPLETED
  CANCELLED
  NO_SHOW
}

model Availability {
  id              String   @id @default(cuid())
  contributorId   String
  contributor     User     @relation(fields: [contributorId], references: [id])

  dayOfWeek       Int      // 0=Sunday, 6=Saturday
  startTime       String   // "09:00" in contributor's timezone
  endTime         String   // "17:00"
  timezone        String   @default("America/New_York")

  createdAt       DateTime @default(now())
}

model Call {
  id              String     @id @default(cuid())
  patientId       String
  patient         User       @relation("PatientCalls", fields: [patientId], references: [id])
  contributorId   String
  contributor     User       @relation("ContributorCalls", fields: [contributorId], references: [id])

  scheduledAt     DateTime
  durationMinutes Int        @default(30) // 30 or 60
  status          CallStatus @default(REQUESTED)
  videoRoomUrl    String?    // Twilio/Daily.co room URL
  questionsInAdvance String? @db.Text

  price           Float      // Total price paid by patient
  platformFee     Float      // Platform's cut (20-30%)
  contributorPayout Float    // What contributor receives

  // Reminder tracking
  dayReminderSent  DateTime?  // When day-before reminder was sent
  hourReminderSent DateTime?  // When hour-before reminder was sent

  reviews         Review[]
  reports         Report[]
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([contributorId, scheduledAt])
  @@index([patientId])
}

// ─── Reviews & Ratings ───

model Review {
  id            String     @id @default(cuid())
  authorId      String
  author        User       @relation("ReviewAuthor", fields: [authorId], references: [id])
  subjectId     String
  subject       User       @relation("ReviewSubject", fields: [subjectId], references: [id])

  recordingId   String?
  recording     Recording? @relation(fields: [recordingId], references: [id])
  callId        String?
  call          Call?      @relation(fields: [callId], references: [id])

  rating        Int        // 1-5
  matchRelevance Int?      // 1-5 - how well matched was the contributor
  helpfulness   Int?       // 1-5
  comment       String?    @db.Text

  createdAt     DateTime   @default(now())
}

// ─── Payments ───

enum PaymentType {
  RECORDING_PURCHASE
  CALL_PAYMENT
  CONTRIBUTOR_PAYOUT
  SUBSCRIPTION
  GROUP_SESSION_PAYMENT
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Payment {
  id              String        @id @default(cuid())
  userId          String
  user            User          @relation(fields: [userId], references: [id])

  type            PaymentType
  amount          Float
  currency        String        @default("usd")
  status          PaymentStatus @default(PENDING)
  stripePaymentId String?
  stripeSessionId String?       @unique
  metadata        Json?

  recordingAccess RecordingAccess?
  seriesAccess    SeriesAccess?
  createdAt       DateTime      @default(now())
}

// ─── Recording Access ───

model RecordingAccess {
  id          String    @id @default(cuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  recordingId String
  recording   Recording @relation(fields: [recordingId], references: [id], onDelete: Cascade)
  paymentId   String?   @unique
  payment     Payment?  @relation(fields: [paymentId], references: [id])
  grantedAt   DateTime  @default(now())

  @@unique([userId, recordingId])
}

// ─── Recording Series ───

enum SeriesStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model RecordingSeries {
  id              String            @id @default(cuid())
  contributorId   String
  contributor     User              @relation("UserSeries", fields: [contributorId], references: [id])

  title           String
  description     String?           @db.Text

  // Pricing: discount off sum of individual prices
  discountPercent Float             @default(15)  // e.g., 15% off

  // Denormalized for search/display
  procedureType   String

  status          SeriesStatus      @default(DRAFT)

  recordings      SeriesRecording[]
  access          SeriesAccess[]

  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([contributorId, status])
}

model SeriesRecording {
  id              String            @id @default(cuid())
  seriesId        String
  series          RecordingSeries   @relation(fields: [seriesId], references: [id], onDelete: Cascade)
  recordingId     String
  recording       Recording         @relation(fields: [recordingId], references: [id])

  sequenceNumber  Int               // Order: 1, 2, 3...

  @@unique([seriesId, recordingId])
  @@unique([seriesId, sequenceNumber])
}

model SeriesAccess {
  id              String            @id @default(cuid())
  userId          String
  user            User              @relation(fields: [userId], references: [id])
  seriesId        String
  series          RecordingSeries   @relation(fields: [seriesId], references: [id])
  paymentId       String?           @unique
  payment         Payment?          @relation(fields: [paymentId], references: [id])
  grantedAt       DateTime          @default(now())

  @@unique([userId, seriesId])
}

// ─── Reports ───

enum ReportStatus {
  PENDING
  REVIEWED
  ACTION_TAKEN
  DISMISSED
}

model Report {
  id          String   @id @default(cuid())

  reporterId  String
  reporter    User     @relation("ReportsSubmitted", fields: [reporterId], references: [id])

  // What's being reported (one of these)
  recordingId String?
  recording   Recording? @relation(fields: [recordingId], references: [id])
  userId      String?
  reportedUser User?   @relation("ReportsReceived", fields: [userId], references: [id])
  callId      String?
  call        Call?    @relation(fields: [callId], references: [id])

  reason      String   // "inappropriate", "spam", "misleading", "harassment", "other"
  details     String?  @db.Text // Additional context from reporter
  status      ReportStatus @default(PENDING)

  adminNotes  String?  @db.Text
  resolvedAt  DateTime?
  resolvedBy  String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])
  @@index([reporterId])
}

// ─── Group Sessions ───

enum GroupSessionStatus {
  SCHEDULED
  CONFIRMED
  COMPLETED
  CANCELLED
}

model GroupSession {
  id                String             @id @default(cuid())
  contributorId     String
  contributor       User               @relation("ContributorGroupSessions", fields: [contributorId], references: [id])
  title             String
  description       String?            @db.Text
  procedureType     String
  scheduledAt       DateTime
  durationMinutes   Int                @default(60)
  maxCapacity       Int
  minAttendees      Int                @default(3)
  pricePerPerson    Float
  status            GroupSessionStatus @default(SCHEDULED)
  videoRoomUrl      String?
  freeForSubscribers Boolean           @default(true)
  dayReminderSent   DateTime?
  hourReminderSent  DateTime?
  minimumCheckAt    DateTime?
  participants      GroupSessionParticipant[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  @@index([procedureType, status])
  @@index([contributorId])
  @@index([scheduledAt, status])
}

model GroupSessionParticipant {
  id              String       @id @default(cuid())
  groupSessionId  String
  groupSession    GroupSession @relation(fields: [groupSessionId], references: [id], onDelete: Cascade)
  userId          String
  user            User         @relation(fields: [userId], references: [id])
  pricePaid       Float
  wasSubscriber   Boolean      @default(false)
  paymentId       String?
  stripeSessionId String?
  status          String       @default("REGISTERED")
  createdAt       DateTime     @default(now())

  @@unique([groupSessionId, userId])
  @@index([userId])
}

// ─── Recommendations ───

enum RecommendationCategory {
  RECOVERY_PRODUCT
  PT_PROVIDER
  MASSAGE_THERAPY
  MEDICAL_PROVIDER
  APP_OR_TOOL
  BOOK_OR_RESOURCE
  OTHER
}

enum RecommendationStatus {
  ACTIVE
  HIDDEN
  REMOVED
}

enum EndorsementSource {
  MANUAL
  AI_EXTRACTED
}

model Recommendation {
  id               String                   @id @default(cuid())
  name             String
  normalizedName   String
  category         RecommendationCategory
  procedureType    String
  description      String?                  @db.Text
  location         String?
  url              String?
  priceRange       String?
  status           RecommendationStatus     @default(ACTIVE)
  endorsementCount Int                      @default(0)
  helpfulCount     Int                      @default(0)
  createdById      String
  createdBy        User                     @relation("RecommendationsCreated", fields: [createdById], references: [id])
  endorsements     RecommendationEndorsement[]
  votes            RecommendationVote[]
  comments         RecommendationComment[]
  createdAt        DateTime                 @default(now())
  updatedAt        DateTime                 @updatedAt

  @@unique([normalizedName, procedureType])
  @@index([procedureType, status])
}

model RecommendationEndorsement {
  id               String            @id @default(cuid())
  recommendationId String
  recommendation   Recommendation    @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  contributorId    String
  contributor      User              @relation("UserEndorsements", fields: [contributorId], references: [id])
  comment          String?           @db.Text
  recoveryPhase    String?
  source           EndorsementSource @default(MANUAL)
  sourceId         String?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt

  @@unique([recommendationId, contributorId])
}

model RecommendationVote {
  id               String         @id @default(cuid())
  recommendationId String
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  userId           String
  user             User           @relation("UserRecommendationVotes", fields: [userId], references: [id])
  createdAt        DateTime       @default(now())

  @@unique([recommendationId, userId])
}

model RecommendationComment {
  id               String         @id @default(cuid())
  recommendationId String
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)
  userId           String
  user             User           @relation("UserRecommendationComments", fields: [userId], references: [id])
  content          String         @db.Text
  createdAt        DateTime       @default(now())

  @@index([recommendationId, createdAt])
}

// ─── Direct Messaging ───

model Conversation {
  id             String   @id @default(cuid())
  participant1Id String
  participant1   User     @relation("ConversationParticipant1", fields: [participant1Id], references: [id])
  participant2Id String
  participant2   User     @relation("ConversationParticipant2", fields: [participant2Id], references: [id])
  lastMessageAt  DateTime @default(now())
  createdAt      DateTime @default(now())

  messages       Message[]

  @@unique([participant1Id, participant2Id])
  @@index([participant1Id, lastMessageAt])
  @@index([participant2Id, lastMessageAt])
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         User         @relation("MessageSender", fields: [senderId], references: [id])
  content        String       @db.Text
  isRead         Boolean      @default(false)
  createdAt      DateTime     @default(now())

  @@index([conversationId, createdAt])
}

// ─── Recovery Journal ───

model JournalEntry {
  id            String   @id
  patientId     String
  patient       User     @relation(fields: [patientId], references: [id], onDelete: Cascade)
  procedureType String
  recoveryWeek  Int?
  painLevel     Int      // 1-10
  mobilityLevel Int      // 1-10
  mood          Int      // 1-5
  notes         String?  @db.Text
  milestones    String[] @default([])
  triggers      String[] @default([])
  isFlare       Boolean  @default(false)
  energyLevel   Int?
  isShared      Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([patientId, procedureType])
  @@index([patientId, createdAt(sort: Desc)])
  @@index([isShared, patientId])
}

// ─── Journal Sharing ───

model JournalShare {
  id            String   @id
  patientId     String
  patient       User     @relation("PatientJournalShares", fields: [patientId], references: [id], onDelete: Cascade)
  contributorId String
  contributor   User     @relation("ContributorJournalShares", fields: [contributorId], references: [id], onDelete: Cascade)
  createdAt     DateTime @default(now())

  @@unique([patientId, contributorId])
  @@index([patientId])
  @@index([contributorId])
}

// ─── Subscriber Views (for subscription payout tracking) ───

model SubscriberView {
  id          String   @id @default(cuid())
  userId      String
  recordingId String
  viewedAt    DateTime @default(now())

  user        User      @relation(fields: [userId], references: [id])
  recording   Recording @relation(fields: [recordingId], references: [id])

  @@unique([userId, recordingId])
}
